# Async-fork笔记

### 摘要

现代的内存数据库在打快照时，常使用fork创建子进程，然后将子进程内存空间的内容进行永久化存储。然而，linux的fork需要复制所有的页表项，耗时较长。这段时间内数据库主进程无法响应请求，造成“latency spike”。

为解决这一问题，本文将复制页表项的过程放到子进程中执行，使父进程可以快速返回，响应请求，从而大大减少延迟。

https://drive.google.com/drive/folders/1xkwhyYmyDV5dD-X03ge1CmwUBNnGgN4X?usp=sharing

### 1. 现有的解决问题的方法

1. 使用较大的页面，减少拷贝页表的时间。但是被证明性能不好。
2. 父子进程共享页表。但是会造成数据泄露。

### 2. async fork的问题

异步操作可能导致不一致性（比如保存了在打快照时还不存在的数据），因此async-fork的实现并不是trivial的。

解决方法是**父进程主动拷贝PTE。**

### 3. 主动拷贝PTE

页表项的分级从上至下依次是：PGD、P4D（可能不存在）、PUD、PMD、PTE。父进程负责拷贝前三项，子进程负责拷贝后两项。

父进程在修改PTE时，如果子进程还没有拷贝这个PTE，就主动将该PTE对应的PMD、以及该PMD下的512个PTE全部拷贝到子进程。

复用了PMD项中的“R/W”标志位，用来表示子进程是否已经完成了该PMD的拷贝。

**主动拷贝PTE有两个主要问题：**

1. 除了用户操作，其他OS的操作也可能导致PTE变化，因此需要**检测PTE的修改**。解决方法在4
2. 异步fork的过程可能出错（比如内存不足），需要有**错误处理机制**（将进程状态恢复到fork之前）。具体见5

### 4. 检测PTE的修改

OS对PTE的修改主要分为两类：

1. 对VMA的修改引起对PTE的修改。

   - VMA的删除、合并、创建等会造成VMA的PMD项的改动**（会引起PTE修改吗？）**。

   - 这种情况下会检查VMA下所有PMD的修改标志位。
   - 当VMA较大时，检查所有PMD比较耗时，因此为VMA引入一个**双向指针**。在进入async-fork时，为父子进程的VMA初始化一个指针指向对方，如果子进程完成了该VMA的拷贝、或者父进程主动完成了该VMA的拷贝，则将指针置为空。这样，父进程可以简单的检查该指针的值判断是否需要检查该VMA内的PMD。
   - **该双向指针在错误处理机制里复用，存储错误码**

2. 对PMD和PTE本身直接修改：

   - 本文总结了Linux中对PMD和PTE的所有修改，并在每个位置进行检查（和主动拷贝）
   - 只检查对应PMD的修改标志位。

### 5. 错误处理机制

**目标**：当子进程在拷贝过程中发生错误时，将父进程的状态恢复成“调用Async-fork之前“。

可能在三个阶段出现错误，有不同的处理方法

1. 父进程拷贝PGD、PUD时：
   - 父进程回滚所有有写保护的PMD**（为什么是PMD）**
2. 子进程拷贝PMD、PTE时：
   - 子进程回滚所有未拷贝的PMD，然后向子进程发送一个**（为什么是向子进程）**SIGKILL信号，在返回到用户态时删除子进程。
3. 父进程主动拷贝时：
   - 只回滚“正在拷贝的PMD所在的VMA下的所有PMD”，这是为了避免与子进程争夺PMD的锁**（为什么？）**
   - 用VMA中的双向指针的空间存储一个错误码。
   - 子进程在拷贝一个VMA的PMD/PTE时，要先检查这个指针是否是错误码，如果是，就执行第二种处理方法。

#### 疑问：没提怎么回滚数据

猜想：对于未改动的数据：不需要操作；对于改动了的数据：子进程中已经根据COW机制和父进程的主动保存机制，保存了原来的数据，可以依据子进程的数据回滚。

### 6. 一些优化和具体实现方法

- 子进程创建多个内核线程来拷贝PMD/PTE，还能减少父进程主动拷贝PTE的次数，提高性能。
- ![image-20231126110953563](/Users/beityluo/Library/Application Support/typora-user-images/image-20231126110953563.png)

- 用一个参数F来决定是否要用Async-fork。当用户将一个进程添加到一个memory cgroup时，可以传递这个参数，同时还能控制子进程用几个内核线程来拷贝PMD/PTE。
- 用kernel module方式实现了一个hook函数（实际分成了两类函数）。传递FAST参数，则只拷贝PGD和PUD；传递SLOW参数则只拷贝PMD和PTE。
- 父进程在fork阶段传递FAST参数，在主动拷贝PTE时传递SLOW参数。子进程在拷贝页表时传递SLOW参数。

- **可能的问题**：在子进程还没结束前，父进程就又调用了一次fork。目前本文对此不做过多研究，因为通常数据库的fork频率是几十秒的量级，不太可能出现这种情况。本文的实现保证了VMA同时只会被一个子进程拷贝。

### 7. 实验

#### 基础实验

- baseline：On-demond-fork
  - “没用原始redis是因为性能相差过大，十倍以上”
  - 但是用了岂不是更好吗？

- 测试指标：snapshot query的99-ile latency，max-latency
- 测试变量：
  - 两种数据库：Redis和KeyDB
  - 不同大小：1、2、4、8、16、32、64GB

#### 其他实验

1. 中断次数：探究为什么async-fork表现好：因为中断次数少
2. 不同的set/get模式下表现差异
3. 不同数量的client下表现差异
4. 不同数量拷贝页表的子进程下的表现差异